# JUCE_ARA

This repository is a fork of the [JUCE 5 develop branch](https://github.com/WeAreROLI/JUCE) with additions that enable it to generate [ARA plugins](https://www.celemony.com/en/service1/about-celemony/technologies) in the VST3 or AudioUnit format.
The fork is currently being maintained by [Celemony](https://www.celemony.com) and [SoundRadix](https://www.soundradix.com), with the goal of it being picked up eventually by [ROLI](https://www.juce.com) for main line JUCE.

In order to use this branch you'll need access to the [ARA SDK](http://www.celemony.com/en/service1/about-celemony/technologies) - if you're a developer and would like access to the latest ARA SDK release, send an email to [ara@celemony.com](mailto:ara@celemony.com?Subject=JUCE%20ARA%20integration).

Current ARA SDK compatibility version: 1.9.7.001

For feedback and questions, please contact Celemony via [ara@celemony.com](mailto:ara@celemony.com?Subject=JUCE%20ARA%20integration).

### Getting started:

We've made modifications to the Projucer to enable it to work with the ARA 2.0 SDK. These modifications allow building VST3 and AudioUnit plugins that can be loaded as ARA plugins by a compatible host. 

To create an ARA plugin, clone the develop branch of Celemony's [JUCE fork](https://github.com/Celemony/JUCE_ARA/tree/develop) build the [Projucer](https://github.com/Celemony/JUCE_ARA/tree/develop/extras/Projucer) (projects for Visual Studio and Xcode are checked in to the repository.)

Once you have the ARA version of the Projucer built you can use it to specify your global ARA path like so:

<img src="https://i.imgur.com/fRjU8kB.png"/>

This ARA SDK path will be used for new ARA plugin projects, but can also be configured per project.

Once the SDK has been located we can create a new Audio Plug-In project like so

<img src="https://i.imgur.com/cqsEA18.png"/>

We specifically want to create an ARA plugin. This is not one of the main types in the template window but can be selected like so:

<img src="https://i.imgur.com/mY6Z1XL.png"/>

If you've already got a JUCE audio plugin project, you can enable ARA in our version of the Projucer using the "Enable ARA" checkbox. 
However, you'll have to add your own document controller implementation - referencing the autogenerated ARA Audio Plug-In project is a good starting point for enabling ARA in existing plugins. 

<img src="https://i.imgur.com/dq9F1X8.png"/>

The generated plugin will have, in addition to the standard PluginProcessor and PluginEditor classes, a PluginARADocumentController file containing a class that overrides the ARA::PlugIn::DocumentController type.

<img src="https://i.imgur.com/JqNIe2b.png"/>

This version of the Projucer supports ARA for VST3 and AudioUnit, so make sure at least one of these plugin formats is checked
<img src="https://i.imgur.com/7wWWPuK.png"/>

We can also edit other ARA plugin factory properties such as available content types and transformation flags as well as the plugin factory identifier.

With ARA enabled we can edit various ARA factory properties plugin factory properties such as available content types and transformation flags as well as the plugin factory identifier.

<img src="https://i.imgur.com/mJoXIxG.png"/>

This should be enough to generate an empty ARA plugin that will appear in an ARA host, such as Studio One or SONAR. For a more complete example of an ARA plugin see the [ARA Sample Project](https://github.com/Celemony/JUCE_ARA/tree/develop/examples/ARA/ARASampleProject) checked in to this repository. 


### JUCE and the ARA API

#### ARADocumentController

As is the case in the ARA C++ library, the `juce::ARADocumentController` class must be subclassed by your
ARA plugin. The ARA host will use your document controller to build a representation of the ARA document for
your plugin - by default the `juce::ARADocumentController` will create the classes outlined below, but your plugin should override the `doCreate` functions in order to create objects that suit your purpose. 

In the 
[ARA Sample Project DocumentController class](https://github.com/Celemony/JUCE_ARA/tree/develop/examples/ARA/ARASampleProject/Source/ARASampleProjectDocumentController.h)
we override `doCreatePlaybackRenderer` in order to return a custom `ARAPlaybackRenderer` instance 
(see the section below on plugin instance roles for information regarding `ARAPlaybackRenderer`.)


#### ARA Model Objects

To make ARA easier to integrate with existing JUCE code, we've subclassed the C++ classes provided 
in the ARA SDK into counterparts in the `juce` namespace:
- `ARA::PlugIn::Document` ==> `juce::ARADocument`
- `ARA::PlugIn::MusicalContext` ==> `juce::ARAMusicalContext`
- `ARA::PlugIn::RegionSequence` ==> `juce::ARARegionSequence`
- `ARA::PlugIn::AudioSource` ==> `juce::ARAAudioSource`
- `ARA::PlugIn::AudioModification` ==> `juce::ARAAudioModification`
- `ARA::PlugIn::PlaybackRegion` ==> `juce::ARAPlaybackRegion`

These model objects can be subclassed further by overriding the `ARADocumentController::doCreate` 
functions as needed, i.e
```
class MyCustomAudioSource : public juce::ARAAudioSource
{
    using juce::ARAAudioSource::ARAAudioSource;
};

class MyCustomDocumentController : public juce::ARADocumentController
{
    ARA::PlugIn::AudioSource* doCreateAudioSource (ARA::PlugIn::Document* document, ARA::ARAAudioSourceHostRef hostRef) 
    noexcept override
    {
        return new MyCustomAudioSource (static_cast<ARADocument*> (document), hostRef);
    }
};
```


#### Listeners

To make things feel more "JUCEy", we've given each JUCE model object a `Listener` base class 
with virtual callbacks that can be overridden to receive notifications related to the ARA model graph 
and host rendering / UI state. These callbacks meant to replace the `will/did` functions that would 
be overridden by an `ARA::PlugIn::DocumentController` implementation using the ARA C++ library. 

We've also added this `Listener` pattern to other classes, such as the 
`ARAEditorView` instance role which helps manage selection and UI state, see [below](#ara-plugin-instance-roles).

Listener updates are subscribed to on a per-object basis. For example, if you need to 
keep track of the properties of a particular `ARAPlaybackRegion`, you must subclass 
`ARAPlaybackRegion::Listener` and and add/remove yourself as a listener of that playback region
via `addListener` and `removeListener`.  

```
class PlaybackRegionManager  : public ARAPlaybackRegion::Listener
{
public:
    PlaybackRegionManager(ARAPlaybackRegion* region)
        : myRegion (region)
    {
        myRegion->addListener (this);
    }
    ~PlaybackRegionManager() 
    {
        myRegion->removeListener (this);
    }

private:
    ARAPlaybackRegion* myRegion;
};
```

See the [ARA Sample Project PlaybackRegionView class](https://github.com/Celemony/JUCE_ARA/tree/develop/examples/ARA/ARASampleProject/Source/PlaybackRegionView.h)
for an example of several `Listener` implementations in action. 


#### ARA PlugIn Instance Roles

When an ARA plug-in is instantiated by the host it will take on one or more instance roles 
as defined by the ARA API. To represent this concept in JUCE we've created two extension classes:

The `AudioProcessorARAExtension` class, meant to be subclassed by the JUCE plugin's `AudioProcessor`
implementation, allows access to all three plugin instance roles bound to the JUCE plugin instance.
The two renderer roles (`ARAPlaybackRenderer` and `ARAEditorRenderer`) will be used by an `AudioProcessor`
instance, so they've been given similar lifetime management functions:
- `ARAPlaybackRenderer::prepareToPlay` - do any pre-playback preparation
- `ARAPlaybackRenderer::processBlock` - render audio samples
- `ARAPlaybackRenderer::releaseResources` - clean up resources while not playing

An implementation of an `ARAPlaybackRenderer` can be found in the 
[ARA Sample Project PlaybackRenderer class](https://github.com/Celemony/JUCE_ARA/tree/develop/examples/ARA/ARASampleProject/Source/ARASampleProjectPlaybackRenderer.h). 

The `AudioProcessorEditorARAExtension` class, meant to be subclassed by the JUCE plugin's `AudioProcessorEditor`
implementation, allows access to the `ARAEditorView` role and helps the plugin interact with host selection
and UI state. 

Ultimately it's up to the host to decide when and where to instantiate your plugin and what roles its meant
to fulfill. To query whether or not a given plugin instance is meant to fulfill a particular role, we've
given these extension classes the following convenience functions:
```
// if any isX returns false, the corresponding getX will return nullptr
bool AudioProcessorARAExtension::isARAPlaybackRenderer() const noexcept;
bool AudioProcessorARAExtension::getARAPlaybackRenderer() const noexcept;

bool AudioProcessorARAExtension::isARAEditorRenderer() const noexcept;
bool AudioProcessorARAExtension::getARAEditorRenderer() const noexcept;

bool AudioProcessorARAExtension::isARAEditorView() const noexcept;
bool AudioProcessorARAExtension::getARAEditorView() const noexcept;

bool AudioProcessorEditorARAExtension::isARAEditorView() const noexcept;
bool AudioProcessorEditorARAExtension::getARAEditorView() const noexcept;
```


#### Audio Readers

Reading large buffers of audio samples at will is a key component of the ARA API. Because the
concept of audio readers already exists in JUCE, we've subclassed the existing `juce::AudioFormatReader` 
to read audio samples via ARA in a class called `juce::ARAAudioSourceReader` that allows reading samples
from a single `ARAAudioSource`. We can construct an `ARAAudioSourceReader` via the `ARADocumentController ` 
using its `createAudioSourceReader` function. 

We've also created reader classes that can use an `ARAPlaybackRenderer` instance to read samples as 
if they were being output by the renderer instance. This is useful if you want to deal with playback regions
instead of the original audio source samples. These readers can operate on a distinct group of
`ARAPlaybackRegions` using an `ARAPlaybacRegionReader` as well as an entire `ARARegionSequence` using
`ARARegionSequenceReader`. 

Once created, the our readers can be treated like any other `AudioFormatReader` - the 
[ARA Sample Project PlaybackRegionView class](https://github.com/Celemony/JUCE_ARA/tree/develop/examples/ARA/ARASampleProject/Source/PlaybackRegionView.h)
takes advantage of this by giving a `juce::AudioThubnail` instance an `ARAPlaybackRegionReader` to draw a
visualization of playback region waveform. 


### Further Additions

Our goal with this fork is to make ARA plugin development as easy and accessible as possible. We'll 
continue to update this repository as new features are designed and developed. Some possible future additions:
- minimizing the casts required from `ARA::PlugIn` classes to their `juce` equivalents
- better UI integration with JUCE using `juce::LookAndFeel`